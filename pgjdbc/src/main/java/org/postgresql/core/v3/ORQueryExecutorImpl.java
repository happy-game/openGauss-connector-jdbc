/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025-2025. All rights reserved.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 */

package org.postgresql.core.v3;

import org.postgresql.core.ORBaseConnection;
import org.postgresql.core.ORCachedQuery;
import org.postgresql.core.ORQueryExecutor;
import org.postgresql.core.ORStream;
import org.postgresql.core.ORParameterList;
import org.postgresql.core.ORField;
import org.postgresql.core.ORDataType;
import org.postgresql.core.OutParams;
import org.postgresql.jdbc.ORCursorResultSet;
import org.postgresql.util.ORPackageHead;
import org.postgresql.util.PSQLState;
import org.postgresql.util.GT;
import org.postgresql.util.PSQLException;
import org.postgresql.util.ORRequestCommand;
import org.postgresql.jdbc.ORStatement;
import org.postgresql.log.Log;
import org.postgresql.log.Logger;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.io.IOException;

/**
 * QueryExecutor implementation for the ogRAC protocol.
 *
 * @author zhangting
 * @since  2025-06-29
 */
public class ORQueryExecutorImpl implements ORQueryExecutor {
    private static Log LOGGER = Logger.getLogger(ORQueryExecutorImpl.class.getName());
    private static final int CURSOR_FLAG = 256;
    private static final int LEN_OPERATION = 16777200;
    private static final int QUERY_FLAG_OPERATION = 4 * 1024 - 1;
    private static final int QUERY_MODE_OPERATION = 4 * 1024;
    private static final int BYTE0_SIGN = 0;
    private static final int BYTE4_SIGN = 1;
    private static final int BYTE8_SIGN = 2;
    private static final int PACKAGE_HEAD_SIZE = 16;
    private static final int COLUMNS_THRESHOLD = 13;
    private static final int GENERATED_KEY_FLAG = 16;
    private static final int SELECT_SQL = 1;
    private static final int UPDATE_SQL = 2;
    private static final int INSERT_SQL = 3;
    private static final int DELETE_SQL = 4;
    private static final int MERGE_SQL = 5;
    private static final int DML_SQL = 1;
    private static final int DCL_SQL = 2;
    private static final int DDL_SQL = 3;
    private static final int TC_SQL = 4;
    private static final int EXPLAIN_SQL = 5;
    private static final int VERSION_23 = 23;

    private ORStream orStream;
    private ORBaseConnection connection;
    private ORPackageHead packageHead;
    private boolean isClosed = false;

    /**
     * query executor constructor
     *
     * @param orStream  orStream
     * @param connection connection
     * @throws IOException if an I/O error occurs
     */
    public ORQueryExecutorImpl(ORStream orStream, ORBaseConnection connection) {
        this.orStream = orStream;
        this.connection = connection;
        this.packageHead = orStream.getPackageHead();
    }

    @Override
    public void execute(ORCachedQuery cachedQuery, List<ORParameterList> batchParameters)
            throws SQLException {
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            if (cachedQuery.isAutoGeneratedKeys()) {
                short flags = (short) (packageHead.getFlags() | GENERATED_KEY_FLAG);
                packageHead.setFlags(flags);
            }
            short statId = (short) cachedQuery.getStatement().getMark();
            if (cachedQuery.isPrepare() && statId != -1) {
                sendPrepareQuery(cachedQuery, batchParameters);
            } else {
                sendQuery(cachedQuery, batchParameters);
            }
            processResults(cachedQuery);
            int headRequestCount = packageHead.getRequestCount();
            int requestCount = orStream.getRequestCount();
            while (headRequestCount < requestCount) {
                processResults(cachedQuery);
                headRequestCount = packageHead.getRequestCount();
            }
            if (headRequestCount > requestCount) {
                throw new PSQLException(GT.tr("request count error, actual request number is "
                        + requestCount + ", head request count is " + headRequestCount),
                        PSQLState.DATA_ERROR);
            }
        } catch (IOException e) {
            try {
                orStream.getSocket().close();
            } catch (IOException e2) {
                LOGGER.trace("Catch IOException on close:", e2);
            }
            isClosed = true;
            String socketStatus = getSocketStatus();
            throw new PSQLException(GT.tr(socketStatus + "An I/O error occured while "
                    + "sending to the backend." + " detail: " + e.getMessage() + "; target host: "
                    + connection.getHostSpec()), PSQLState.CONNECTION_FAILURE, e);
        } catch (SQLException e2) {
            throw e2;
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
    }

    private String getSocketStatus() throws SQLException {
        if (connection.isClosed()) {
            return "socket is closed; ";
        }
        return "socket is not closed; ";
    }

    @Override
    public void commit() throws IOException, SQLException {
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            packageHead.setExecCmd((byte) ORRequestCommand.COMMIT);
            transactionHandle();
            processResults(null);
        } catch (IOException e) {
            throw new PSQLException("An error occurred while commit transaction.",
                    PSQLState.CONNECTION_FAILURE_DURING_TRANSACTION, e);
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
    }

    @Override
    public void rollback() throws IOException, SQLException {
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            packageHead.setExecCmd((byte) ORRequestCommand.ROLLBACK);
            transactionHandle();
            processResults(null);
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
    }

    @Override
    public void close() {
        if (isClosed) {
            return;
        }
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            packageHead.setExecCmd((byte) ORRequestCommand.LOGOUT);
            transactionHandle();
        } catch (IOException ioe) {
            LOGGER.trace("Discarding IOException on close:", ioe);
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
        isClosed = true;
    }

    @Override
    public void closeResultSet(ORStatement ctStatement) {
        isClosed = true;
    }

    @Override
    public boolean isClosed() {
        return isClosed;
    }

    @Override
    public void fetch(ORCachedQuery cachedQuery) throws SQLException, IOException {
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            packageHead.setExecCmd((byte) ORRequestCommand.FETCH);
            packageHead.setRequestCount(orStream.addRequestCount());
            byte[] headBytes = getHeadBytes();
            orStream.sendInteger4(PACKAGE_HEAD_SIZE + 4);
            orStream.send(headBytes);
            short statId = (short) cachedQuery.getStatement().getMark();
            orStream.sendInteger2(statId);
            orStream.sendChar(0);
            orStream.sendChar(0);
            orStream.flush();
            processResults(cachedQuery);
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
    }

    @Override
    public void cancel() throws IOException, SQLException {
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            packageHead.setExecCmd((byte) ORRequestCommand.CANCEL);
            packageHead.setRequestCount(orStream.addRequestCount());
            byte[] headBytes = getHeadBytes();
            int sessionIdLen = 4;
            int requestCountLen = 4;
            int sessionNumberLen = 4;
            int dataLen = PACKAGE_HEAD_SIZE + sessionIdLen + requestCountLen + sessionNumberLen;
            orStream.sendInteger4(dataLen);
            orStream.send(headBytes);
            orStream.sendInteger4(orStream.getSessionId());
            orStream.sendInteger4(orStream.getRequestCount());
            orStream.sendInteger4(orStream.getSessionNumber());
            orStream.flush();
            processResults(null);
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
    }

    private void transactionHandle() throws IOException {
        packageHead.setRequestCount(orStream.addRequestCount());
        byte[] headBytes = getHeadBytes();
        orStream.sendInteger4(PACKAGE_HEAD_SIZE);
        orStream.send(headBytes);
        orStream.flush();
    }

    @Override
    public void freeStatement(ORStatement stat) throws IOException, SQLException {
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            packageHead.setExecCmd((byte) ORRequestCommand.FREE_STMT);
            packageHead.setRequestCount(orStream.addRequestCount());
            byte[] headBytes = getHeadBytes();

            orStream.sendInteger4(PACKAGE_HEAD_SIZE + 4);
            orStream.send(headBytes);
            short statId = (short) stat.getMark();
            orStream.sendInteger2(statId);
            orStream.sendChar(0);
            orStream.sendChar(0);
            orStream.flush();
            processResults(null);
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
    }

    private void sendQuery(ORCachedQuery cachedQuery, List<ORParameterList> batchParameters)
            throws SQLException, IOException {
        packageHead.setExecCmd((byte) ORRequestCommand.PREP_AND_EXECUTE);
        packageHead.setRequestCount(orStream.addRequestCount());
        try {
            int msgLen = PACKAGE_HEAD_SIZE;
            msgLen += 4;
            msgLen += 4;

            byte[] sqlBytes = cachedQuery.getSql().getBytes(orStream.getCharset());
            int alignLen = sqlBytes.length % 4 == 0 ? sqlBytes.length
                    : sqlBytes.length + (4 - sqlBytes.length % 4);
            byte[] alignSqlBytes = new byte[alignLen];
            System.arraycopy(sqlBytes, 0, alignSqlBytes, 0, sqlBytes.length);
            msgLen = msgLen + 4 + alignSqlBytes.length;

            msgLen += 4;
            msgLen++;
            msgLen += 3;
            List<byte[]> byteParams = getBytesParam(batchParameters);
            for (byte[] param : byteParams) {
                msgLen += param.length;
            }
            byte[] headData = getHeadBytes();
            orStream.sendInteger4(msgLen);
            orStream.send(headData);
            int statId = cachedQuery.getStatement().getMark();
            orStream.sendInteger2(statId);
            orStream.sendChar(0);
            orStream.sendChar(0);
            byte[] bs = orStream.getInteger4Bytes(0);
            orStream.send(bs);
            orStream.sendInteger4(sqlBytes.length);
            orStream.send(alignSqlBytes);
            orStream.sendInteger2(byteParams.size());
            int fetchSize = cachedQuery.getStatement().getFetchSize();
            orStream.sendInteger2(fetchSize);
            int autoCommit = cachedQuery.getConn().getAutoCommit() ? 1 : 0;
            orStream.sendChar(autoCommit);
            orStream.sendChar(0);
            orStream.sendChar(0);
            orStream.sendChar(0);
            for (byte[] paramToServer : byteParams) {
                orStream.send(paramToServer);
            }
            orStream.flush();
        } catch (IOException | SQLException e) {
            throw e;
        }
    }

    private List<byte[]> getBytesParam(List<ORParameterList> batchParameters) throws SQLException {
        if (batchParameters == null || batchParameters.isEmpty()) {
            return new ArrayList<>();
        }
        int paramCount = batchParameters.get(0).getParamCount();
        int byte4Count = paramCount % 4 == 0 ? paramCount : paramCount + (4 - paramCount % 4);
        byte[] paramType = new byte[byte4Count];
        int[] typeMode = batchParameters.get(0).getDbTypes();
        for (int i = 0; i < paramCount; i++) {
            if (typeMode[i] == ORDataType.TIME) {
                paramType[i] = ORDataType.TIMESTAMP;
            } else {
                paramType[i] = (byte) typeMode[i];
            }
        }

        return encodeParam(batchParameters, paramCount, typeMode, byte4Count, paramType);
    }

    private List<byte[]> encodeParam(List<ORParameterList> batchParameters, int paramCount,
                                     int[] typeMode, int byte4Count, byte[] paramType) {
        List<byte[]> byteParams = new ArrayList<>();
        boolean isHead = true;
        for (ORParameterList paramList : batchParameters) {
            for (int i = 0; i < paramCount; i++) {
                if (typeMode[i] != paramList.getDbTypes()[i]) {
                    return byteParams;
                }
            }
            List<byte[]> byteParam = new ArrayList<>();
            int size = 0;
            byte[] nullSign = new byte[byte4Count];
            int count = paramList.getParamCount();
            int[] inOut = paramList.getInOut();
            for (int i = 0; i < count; i++) {
                if (paramList.getParamValues()[i] == null) {
                    nullSign[i] = (byte) (inOut[i] | 1);
                } else {
                    nullSign[i] = (byte) inOut[i];
                }
                byte[] param = paramList.getByteValue(i);
                if (param == null || param.length == 0) {
                    continue;
                }
                size += param.length;
                byteParam.add(param);
            }
            byte[] allParam = new byte[size];
            int index = 0;
            for (byte[] p : byteParam) {
                System.arraycopy(p, 0, allParam, index, p.length);
                index += p.length;
            }

            int point = 0;
            size += 4;
            size += byte4Count;
            byte[] sizeByte = orStream.getInteger4Bytes(size);
            byte[] paramData = new byte[size];
            if (isHead) {
                size += byte4Count;
                paramData = new byte[size];
                paramList.setParam(paramType, paramData, 0);
                point = paramType.length;
            }
            paramList.setParam(sizeByte, paramData, point);
            point += sizeByte.length;
            paramList.setParam(nullSign, paramData, point);
            point += nullSign.length;
            paramList.setParam(allParam, paramData, point);
            byteParams.add(paramData);
            isHead = false;
        }
        return byteParams;
    }

    private void sendPrepareQuery(ORCachedQuery cachedQuery, List<ORParameterList> batchParameters)
            throws SQLException, IOException {
        packageHead.setExecCmd((byte) ORRequestCommand.EXECUTE);
        packageHead.setRequestCount(orStream.addRequestCount());
        try {
            int msgLen = PACKAGE_HEAD_SIZE;
            msgLen += 6;
            msgLen++;
            msgLen++;
            List<byte[]> byteParams = getBytesParam(batchParameters);
            for (byte[] param : byteParams) {
                msgLen += param.length;
            }
            byte[] headData = getHeadBytes();
            orStream.sendInteger4(msgLen);
            orStream.send(headData);
            int statId = cachedQuery.getStatement().getMark();
            orStream.sendInteger2(statId);
            orStream.sendInteger2(byteParams.size());
            int fetchSize = cachedQuery.getStatement().getFetchSize();
            orStream.sendInteger2(fetchSize);
            int autoCommit = cachedQuery.getConn().getAutoCommit() ? 1 : 0;
            orStream.sendChar(autoCommit);
            orStream.sendChar(0);
            for (byte[] paramToServer : byteParams) {
                orStream.send(paramToServer);
            }
            orStream.flush();
        } catch (IOException | SQLException e) {
            throw e;
        }
    }

    private byte[] getHeadBytes() {
        byte[] flagByte = orStream.getInteger2Bytes(packageHead.getFlags());
        byte[] data = new byte[12];
        int index = 0;
        data[index++] = packageHead.getExecCmd();
        data[index++] = packageHead.getExecResult();
        for (int i = 0; i < flagByte.length; i++) {
            data[index++] = flagByte[i];
        }

        data[index++] = packageHead.getVersion();
        data[index++] = packageHead.getVersion1();
        data[index++] = packageHead.getVersion2();
        data[index++] = 0;
        byte[] serialNumberByte = orStream.getInteger4Bytes(packageHead.getRequestCount());
        for (int i = 0; i < serialNumberByte.length; i++) {
            data[index++] = serialNumberByte[i];
        }
        return data;
    }

    private void processResults(ORCachedQuery cachedQuery) throws SQLException, IOException {
        while (true) {
            packageHead.setSize(orStream.receiveInteger4());
            packageHead.setExecCmd((byte) orStream.receiveChar());
            packageHead.setExecResult((byte) orStream.receiveChar());
            packageHead.setFlags((short) orStream.receiveInteger2());
            packageHead.setVersion((byte) orStream.receiveChar());
            packageHead.setVersion1((byte) orStream.receiveChar());
            packageHead.setVersion2((byte) orStream.receiveChar());
            orStream.receiveChar();
            packageHead.setRequestCount(orStream.receiveInteger4());
            int remainLen = packageHead.getSize() - PACKAGE_HEAD_SIZE;
            int requestCount = orStream.getRequestCount();
            if ((packageHead.getFlags() & CURSOR_FLAG) != 0) {
                sendCursorRequest(cachedQuery);
            } else if (packageHead.getRequestCount() == requestCount && remainLen > 0) {
                getResult(cachedQuery, remainLen);
            }

            if ((packageHead.getFlags() & CURSOR_FLAG) == 0) {
                break;
            }
        }
    }

    private void sendCursorRequest(ORCachedQuery cachedQuery) throws IOException {
        long cursorId = orStream.receiveLong();
        cachedQuery.getStatement().addCursor(cursorId);
        orStream.sendInteger4(PACKAGE_HEAD_SIZE);
        orStream.sendChar(0);
        orStream.sendChar(0);
        orStream.sendInteger2(0);
        orStream.sendChar(1);
        orStream.sendChar(0);
        orStream.sendChar(0);
        orStream.sendChar(0);
        orStream.sendInteger4(orStream.addRequestCount());
        orStream.flush();
    }

    private void getResult(ORCachedQuery cachedQuery, int remainLen)
            throws SQLException, IOException {
        if (packageHead.getExecResult() != 0) {
            handleException(remainLen);
        } else {
            if (packageHead.getExecCmd() == ORRequestCommand.FETCH) {
                orStream.receiveInteger4();
                int total = orStream.receiveInteger2();
                int remain = orStream.receiveChar();
                orStream.receiveChar();
                if (total > 0) {
                    List<int[]> valueLens = new ArrayList<>();
                    List<byte[][]> rows = new ArrayList<>();
                    this.getByteData(valueLens, rows, total);
                    boolean hasRemain = remain == 1;
                    cachedQuery.setNewData(total, valueLens, rows, hasRemain);
                }
            } else if (packageHead.getExecCmd() == ORRequestCommand.EXECUTE) {
                int queryMode = cachedQuery.getStatement().getQueryMode();
                if (queryMode == DCL_SQL || queryMode == DDL_SQL) {
                    cachedQuery.getStatement().setUpdateCount(0);
                } else {
                    orStream.receiveInteger4();
                    int updateCount = orStream.receiveInteger4();
                    cachedQuery.getStatement().setUpdateCount(updateCount);
                    this.handleResult(cachedQuery, cachedQuery.getStatement().getField());
                }
            } else {
                handleData(cachedQuery);
            }
        }
    }

    private void handleException(int remainLen) throws IOException, SQLException {
        int offset = 0;
        orStream.receiveInteger4();
        offset += 4;
        orStream.receiveInteger2();
        offset += 2;
        orStream.receiveInteger2();
        offset += 2;
        orStream.receiveInteger2();
        offset += 2;
        orStream.receiveInteger2();
        offset += 2;
        byte[] errBytes;
        int protocolVersion = orStream.getServerVersion();
        if (orStream.isHandshake()) {
            protocolVersion = orStream.getVersion();
        }
        int msgLen = 0;
        int maxLen = remainLen - offset;
        if (protocolVersion < VERSION_23) {
            errBytes = orStream.receive(maxLen);
            for (int i = 0; i < errBytes.length; i++) {
                if (errBytes[i] == 0) {
                    msgLen = i;
                    break;
                }
            }
        } else {
            msgLen = orStream.receiveInteger4();
            int msgByteLen = msgLen % 4 == 0 ? msgLen : msgLen + (4 - msgLen % 4);
            if (msgByteLen > maxLen) {
                throw new SQLException("message length error.");
            }
            errBytes = orStream.receive(msgByteLen);
        }

        String errorMsg = new String(errBytes, 0, msgLen, orStream.getCharset());
        throw new PSQLException(GT.tr(errorMsg), PSQLState.CONNECTION_FAILURE);
    }

    private void handleData(ORCachedQuery cachedQuery) throws SQLException, IOException {
        ORStatement stat = cachedQuery.getStatement();
        int id = orStream.receiveInteger2();
        stat.setMark(id);
        int statFlag = orStream.receiveInteger2();
        stat.setQueryFlag(statFlag & QUERY_FLAG_OPERATION);
        int queryMode = statFlag / QUERY_MODE_OPERATION & 0x0F;
        stat.setQueryMode(queryMode);
        int cols = orStream.receiveInteger2();
        byte[] ba = orStream.receive(2);
        int paramSize = orStream.bytesToShort(ba);

        for (int i = 0; i < paramSize; i++) {
            orStream.receiveInteger4();
            orStream.receiveInteger4();
        }
        ORField[] fields = new ORField[cols];
        getFieldInfo(fields);
        cachedQuery.getStatement().setField(fields);
        if (queryMode == TC_SQL) {
            OutParams outParams = new OutParams(cachedQuery.getStatement(), orStream);
            outParams.handleOutParam();
        }
        if (queryMode == DCL_SQL || queryMode == DDL_SQL) {
            stat.setUpdateCount(0);
        } else {
            orStream.receiveInteger4();
            int updateCount = orStream.receiveInteger4();
            stat.setUpdateCount(updateCount);
            handleResult(cachedQuery, fields);
        }
    }

    private void getFieldInfo(ORField[] fields) throws IOException {
        for (int i = 0; i < fields.length; i++) {
            fields[i] = new ORField();
            fields[i].setLength(orStream.receiveInteger2());
            fields[i].setPrecision(orStream.receiveChar());
            fields[i].setScale(orStream.receiveChar());
            int dbType = orStream.receiveInteger2();
            fields[i].setTypeInfo(ORDataType.getDataType(dbType));
            byte b = (byte) orStream.receiveChar();
            int nullable = (b & 1);
            fields[i].setNullableFlag(nullable);

            boolean isAutoIncrement = (b & 2) != 0;
            fields[i].setAutoIncrement(isAutoIncrement);
            orStream.receiveChar();
            orStream.receiveInteger2();
            int labelLen = orStream.receiveInteger2();
            fields[i].setLabelLen(labelLen);
            int byte4LabelLen = labelLen;
            if (labelLen % 4 != 0) {
                byte4LabelLen = labelLen + (4 - labelLen % 4);
            }
            byte[] label = orStream.receive(byte4LabelLen);
            String columnLabel = new String(Arrays.copyOf(label, labelLen), orStream.getCharset());
            fields[i].setColumnName(columnLabel);
        }
    }

    private void handleResult(ORCachedQuery cachedQuery, ORField[] fields) throws SQLException, IOException {
        ORStatement stmt = cachedQuery.getStatement();
        byte[] totalBytes = orStream.receive(2);
        int remain = orStream.receiveChar();
        boolean hasRemain = remain == 1;
        orStream.receiveChar();
        orStream.receiveInteger2();
        orStream.receiveInteger2();
        boolean hasParams = ((packageHead.getFlags() & 8) != 0);
        if (hasParams && stmt.getQueryMode() == TC_SQL) {
            OutParams outParams = stmt.getOutParams();
            outParams.handleCallableResult();
            stmt.setCallableRs(outParams.getResultSet());
        }

        int total = orStream.bytesToShort(totalBytes);
        if (fields.length > 0) {
            List<int[]> valueLens = new ArrayList<>();
            List<byte[][]> rows = new ArrayList<>();
            if (total > 0) {
                this.getByteData(valueLens, rows, total);
            }
            cachedQuery.handleResultRows(fields, valueLens, rows, hasRemain);
        }
        if (cachedQuery.isAutoGeneratedKeys() && total > 0) {
            handleGeneratedKeys(cachedQuery, total, hasRemain);
        }
    }

    private void handleGeneratedKeys(ORCachedQuery cachedQuery, int total, boolean hasRemain)
            throws IOException, SQLException {
        ORField[] fields = new ORField[]{new ORField()};
        Object[] typeInfo = ORDataType.getDataType(ORDataType.BIGINT);
        fields[0].setTypeInfo(typeInfo);
        List<byte[][]> generatedKeysRows = new ArrayList<>();
        List<int[]> valueLens = new ArrayList<>();
        int queryFlag = cachedQuery.getStatement().getQueryFlag();
        if (queryFlag == INSERT_SQL || queryFlag == MERGE_SQL) {
            this.getByteData(valueLens, generatedKeysRows, total);
        }
        cachedQuery.handleGeneratedKeys(fields, valueLens, generatedKeysRows, hasRemain);
    }

    private void getByteData(List<int[]> valueLens, List<byte[][]> rows, int total) throws IOException {
        for (int i = 0; i < total; i++) {
            getRow(valueLens, rows);
        }
    }

    private void getRow(List<int[]> valueLens, List<byte[][]> rows) throws IOException {
        orStream.receiveInteger2();
        int columns = orStream.receiveInteger2();
        int[] lens = new int[columns];
        byte[][] value = new byte[columns][];
        int lenOperation = 3;
        if (columns >= COLUMNS_THRESHOLD) {
            lenOperation += ((columns + 3 & LEN_OPERATION) / 4);
        }

        orStream.receiveChar();
        byte[] lenMark = orStream.receive(lenOperation);
        int index = 0;
        int colIndex = 0;
        while (true) {
            int p = index * 4;
            int mark = lenMark[index];
            for (int k = p; k < p + 4; k++) {
                if (k >= columns) {
                    colIndex = k;
                    break;
                }
                int lenId = mark & 3;
                handleValue(lenId, lens, value, k);
                mark = mark >> 2;
                colIndex = k;
            }
            if (colIndex >= columns - 1) {
                break;
            }
            index++;
        }
        valueLens.add(lens);
        rows.add(value);
    }

    private void handleValue(int lenId, int[] valueLen, byte[][] value, int k) throws IOException {
        if (lenId == BYTE0_SIGN) {
            valueLen[k] = -1;
            value[k] = new byte[0];
        } else if (lenId == BYTE4_SIGN) {
            valueLen[k] = 4;
            value[k] = orStream.receive(4);
        } else if (lenId == BYTE8_SIGN) {
            valueLen[k] = 8;
            value[k] = orStream.receive(8);
        } else {
            int len = orStream.receiveInteger2();
            valueLen[k] = len;
            int byte4Len = (4 - (len + 2) % 4) % 4;
            value[k] = orStream.receive(byte4Len + len);
        }
    }

    @Override
    public void fetchCursor(ORCursorResultSet cursorRs) throws SQLException {
        orStream.getLock().lock();
        try {
            packageHead.init(orStream.getServerVersion());
            packageHead.setExecCmd((byte) ORRequestCommand.FETCH);
            packageHead.setRequestCount(orStream.addRequestCount());
            byte[] headBytes = getHeadBytes();
            orStream.sendInteger4(PACKAGE_HEAD_SIZE + 4);
            orStream.send(headBytes);
            short statId = (short) cursorRs.getStatement().getMark();
            orStream.sendInteger2(statId);
            if (!cursorRs.isFetched()) {
                orStream.sendChar(cursorRs.getCursorMode());
            } else {
                orStream.sendChar(0);
            }
            orStream.sendChar(0);
            orStream.flush();
            processCursorResults(cursorRs);
        } catch (IOException e) {
            try {
                orStream.getSocket().close();
            } catch (IOException e2) {
                LOGGER.trace("Catch IOException on close:", e2);
            }
            isClosed = true;
            String socketStatus = getSocketStatus();
            throw new PSQLException(GT.tr(socketStatus + "An I/O error occured while "
                    + "sending to the backend." + " detail: " + e.getMessage() + "; target host: "
                    + connection.getHostSpec()), PSQLState.CONNECTION_FAILURE, e);
        } catch (SQLException e2) {
            throw e2;
        } finally {
            if (orStream.getLock().isHeldByCurrentThread()) {
                orStream.getLock().unlock();
            }
        }
    }

    private void processCursorResults(ORCursorResultSet cursorRs) throws IOException, SQLException {
        while (true) {
            packageHead.setSize(orStream.receiveInteger4());
            packageHead.setExecCmd((byte) orStream.receiveChar());
            packageHead.setExecResult((byte) orStream.receiveChar());
            packageHead.setFlags((short) orStream.receiveInteger2());
            packageHead.setVersion((byte) orStream.receiveChar());
            packageHead.setVersion1((byte) orStream.receiveChar());
            packageHead.setVersion2((byte) orStream.receiveChar());
            orStream.receiveChar();
            packageHead.setRequestCount(orStream.receiveInteger4());
            int remainLen = packageHead.getSize() - PACKAGE_HEAD_SIZE;
            int requestCount = orStream.getRequestCount();
            if (packageHead.getRequestCount() == requestCount && remainLen > 0) {
                getCursorResult(cursorRs, remainLen);
            }
            if ((packageHead.getFlags() & CURSOR_FLAG) == 0) {
                break;
            }
        }
    }

    private void getCursorResult(ORCursorResultSet cursorRs, int remainLen) throws IOException, SQLException {
        if (packageHead.getExecResult() != 0) {
            handleException(remainLen);
        } else {
            handleCursorRows(cursorRs);
        }
    }

    private void handleCursorRows(ORCursorResultSet cursorRs) throws IOException, SQLException {
        ORStatement stat = cursorRs.getStatement();
        if (!cursorRs.isFetched()) {
            int id = orStream.receiveInteger2();
            stat.setMark(id);
            int statFlag = orStream.receiveInteger2();
            stat.setQueryFlag(statFlag & QUERY_FLAG_OPERATION);
            int queryMode = statFlag / QUERY_MODE_OPERATION & 0x0F;
            stat.setQueryMode(queryMode);

            int cols = orStream.receiveInteger2();
            byte[] ba = orStream.receive(2);
            int paramSize = orStream.bytesToShort(ba);

            for (int i = 0; i < paramSize; i++) {
                orStream.receiveInteger4();
                orStream.receiveInteger4();
            }
            ORField[] fields = new ORField[cols];
            getFieldInfo(fields);
            cursorRs.getStatement().setField(fields);
            if (queryMode == TC_SQL) {
                OutParams outParams = new OutParams(cursorRs.getStatement(), orStream);
                outParams.handleOutParam();
                cursorRs.getStatement().setOutParams(outParams);
            }
        }

        if (!cursorRs.isFetched() && cursorRs.getCursorMode() == 1) {
            orStream.receiveInteger4();
        }

        orStream.receiveInteger4();
        byte[] rowsBytes = orStream.receive(2);
        int rowsCount = orStream.bytesToShort(rowsBytes);
        int remainingRows = orStream.receiveChar();
        boolean hasRemain = remainingRows == 1;
        orStream.receiveChar();
        int totalCol = cursorRs.getStatement().getField().length;
        if (totalCol > 0) {
            List<int[]> valueLens = new ArrayList<>();
            List<byte[][]> rows = new ArrayList<>();
            if (rowsCount > 0) {
                this.getByteData(valueLens, rows, rowsCount);
            }
            cursorRs.setCursorFetchInfo(rowsCount, cursorRs.getStatement().getField(), valueLens, rows, hasRemain);
        }
    }
}
